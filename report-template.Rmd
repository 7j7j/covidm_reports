---
author: "LSHTM CMMID COVID-19 Working Group"
date: "`r format(Sys.Date(),'%d %b %Y')`"
output:
  pdf_document:
    fig_caption: yes
params:
  location: Default
  dynamics: "`r data.frame()`"
  contactmatrices: "`r matrix()`"
  poppyra: "`r integer()`"
  day0: "2020-04-01"
title: "`r sprintf('Report for %s', params$location)`"
bibliography: COVID.bib
---
```{r echo=FALSE, include=FALSE}
suppressPackageStartupMessages({
  require(data.table)
  require(ggplot2)
  require(ggthemr)
  require(cowplot)
  require(knitr)
  require(tidyverse)
  require(RColorBrewer)
  
})

reduce_ages <- function(dt) {
  fctr <- function(i, lvls = c("<14", "15-29", "30-44", "45-59", "60+")) {
    factor(
      lvls[i],
      levels = lvls, ordered = T
    )
  }
  dt[between(as.integer(group), 1, 3), age := fctr(1)]
  dt[between(as.integer(group), 4, 6), age := fctr(2)]
  dt[between(as.integer(group), 7, 9), age := fctr(3)]
  dt[between(as.integer(group), 10, 12), age := fctr(4)]
  dt[as.integer(group) >= 13, age := fctr(5)]
}

keepruns <- dynamics[compartment == "cases_reported", .(any = sum(value) > 1), by = run][any == TRUE, run]
refdays <- dynamics[compartment == "cases"][run %in% keepruns, .(firstcase = t[which.max(value > 0)]), by = run]

# subset
subdyn <- dynamics[refdays, on = .(run)][t >= firstcase]
subdyn[, date := t - firstcase]

refday <- 0
reflim <- 90L
ulim <- ceiling(subdyn[t >= reflim][rev(order(t))][compartment == "cases", if (any(value > 0)) t[which.max(value > 0)] else reflim, by = run][, max(V1)] / 30) * 30

reduce_ages(subdyn)
reduce_ages(poppyra)

poppyra[, per_by_group := pop / sum(pop)]
poppyra[, per_by_age := sum(pop), by = age]
poppyra[, per_by_age := per_by_age / sum(pop)]
# only consider simulations with non-zero reported cases


# all simulations get aligned by first reported case on day0

if (!is.na(params$day0)) {
  dtscale <- scale_x_date("Date", expand = c(0, 0))
} else {
  dtscale <- scale_x_continuous("Days from First Case", expand = c(0, 0))
}

col.lbls <- poppyra[, sprintf("%s (%s%%)", age, round(unique(per_by_age) * 100)), by = age]$V1

scale_color_pop <- function(
                            name = "Age Group\n(% of Pop.)",
                            labels = col.lbls,
                            guide = guide_legend(override.aes = list(alpha = 1, size = 2)),
                            ...) {
  scale_color_discrete(
    name = name,
    labels = labels,
    guide = guide
  )
}

thm_main <- theme_minimal(base_size = 8) +
  theme(
    strip.text.y = element_blank(),
    plot.margin = margin(t = 1, l = 2, unit = "line"),
    panel.spacing = unit(x = 0.5, unit = "line")
  )
thm_bottom <- theme_minimal(base_size = 8) + theme(
  axis.title.y = element_blank(),
  axis.text.y = element_blank(),
  panel.grid.major.y = element_blank(),
  strip.text.y = element_blank(),
  plot.margin = margin(t = 1, l = 2, unit = "line")
)

thm_right <- theme_minimal(base_size = 8) + theme(
  axis.text = element_blank(),
  axis.title = element_blank(),
  axis.title.y = element_blank(),
  axis.title.y.right = element_blank(),
  axis.text.y.right = element_blank(),
  strip.text.y = element_blank(),
  panel.grid.major.x = element_blank()
)

compartments <- c("cases_reported", "nonicu_p", "icu_p", "death_o")

compartment_names <- c(
  `cases_reported` = "Symptomatic Cases",
  `nonicu_p` = "Hospitilised Cases (Ward)",
  `icu_p` = "Hospitilised Cases (ICU)",
  `death_o` = "Deaths"
)

calculate_reference_table <- function(subdt,
                                      by = c("run", "date", "population", "compartment")) {
  return(subdt %>% filter(date >= refday, date <= refday + ulim) %>%
    group_by_at(vars(one_of(by))) %>%
    summarise(value = sum(value)) %>% ungroup())
  # return(subdt[between(date, refday, refday+ulim)][,
  #   .(value = sum(value)),
  #   keyby = .(run, date, population, compartment)
  # ])
}

calculate_peaks <- function(refdt, by = c("run", "population", "compartment")) {
  return(refdt %>% group_by_at(vars(one_of(by))) %>%
    top_n(n = 1, wt = value) %>%
    summarise(
      peakdate = date[1],
      peak = max(value)
    ) %>% ungroup())
  # return(refdt[,
  #   .(peakdate = date[which.max(value)], peak=max(value)),
  #   by=.(run, population, compartment)
  # ])
}

calculate_timings <- function(peaks.dt, by = c("population", "compartment")) {
  return(peaks.dt %>% group_by_at(vars(one_of(by))) %>%
    summarise(
      lo.lo = quantile(peakdate, 0.025),
      lo = quantile(peakdate, 0.25),
      md = quantile(peakdate, 0.5),
      hi = quantile(peakdate, 0.75),
      hi.hi = quantile(peakdate, 0.975),
      mx = quantile(peakdate, 1.0),
    ) %>% ungroup())
  # return(peaks.dt[peak != 0, {
  #   qs <- quantile(peakdate, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
  #   names(qs) <- c("lo.lo", "lo", "md", "hi", "hi.hi")
  #   as.list(qs)
  # }, by=.(population, compartment)
  # ])
}

calculate_peak_sizes <- function(peaks.dt, by = c("population", "compartment")) {
  return(peaks.dt %>% group_by_at(vars(one_of(by))) %>%
    summarise(
      lo.lo = quantile(peak, 0.025),
      lo = quantile(peak, 0.25),
      md = quantile(peak, 0.5),
      hi = quantile(peak, 0.75),
      hi.hi = quantile(peak, 0.975),
      mx = quantile(peak, 1.0)
    ) %>% ungroup())
  # return(peaks.dt[peak != 0,{
  #   qs <- quantile(peak, probs = c(0.025, 0.25, 0.5, 0.75, 0.975, 1.0))
  #   names(qs) <- c("lo.lo", "lo", "md", "hi", "hi.hi","mx")
  #   as.list(qs)
  # }, by=.(population, compartment)
  # ])
}

calculate_cumulative_median_values <- function(refdt, by=c("compartment")){
  return(refdt %>%
    group_by_at(vars(one_of(c(by, "run")))) %>%
    # group_by(run) %>% 
    arrange(date) %>%
    mutate(cum_value = cumsum(value)) %>%
    group_by_at(vars(one_of(c(by, "date")))) %>% 
    # group_by(date) %>%
    summarise(median_cum_value = median(cum_value)) %>%
    mutate(median_value = c(median_cum_value[1], diff(median_cum_value))) %>%
    ungroup() %>%
    mutate(compartment = factor(compartment, levels = compartments)))
}

summary_tsplotter <- function(subdt, title = "Case Numbers", timing.title = "Peak Timing", 
                              pop = poppyra, x.main.title = "Number of Cases", use.legend=TRUE) {
  # First calculate all the data
  refdt <- calculate_reference_table(subdt %>% filter(compartment %in% compartments))

  peaks.dt <- calculate_peaks(refdt)
  timing.dt <- calculate_timings(peaks.dt)
  size.dt <- calculate_peak_sizes(peaks.dt)

  if (!is.na(params$day0)) {
    start_date <- as.Date(params$day0)
    timing.dt <- timing.dt %>%
      mutate_if(is.numeric, function(x) {
        start_date + x
      })
    refdt <- refdt %>%
      mutate(date = start_date + date)
    peaks.dt <- peaks.dt %>%
      mutate(peakdate = start_date + peakdate)
    timing_limits <- c(start_date, start_date + ulim)
    timing_scale <- scale_x_date("Date", date_breaks = "1 month", date_labels = "%b", expand = c(0, 0))
    timing_scale_null <- scale_x_date(NULL, date_breaks = "1 month", labels = NULL, expand = c(0, 0))
  } else {
    timing_limits <- c(refday, refday + ulim)
    timing_scale <- dtscale
    timing_scale_null <- dtscale
  }

  # Calculate the median values
  cumulative_median_values <- calculate_cumulative_median_values(refdt)


  # Generate the plots
  p <- refdt %>%
    mutate(compartment = factor(compartment, levels = compartments)) %>%
    group_by(compartment, date) %>%
    summarise(
      mean_value = mean(value),
      std_value = sd(value),
      min_value = min(value),
      max_value = max(value)
    ) %>%
    ggplot(aes(group = compartment, fill = compartment)) +
    labs(subtitle=title)+
    geom_ribbon(aes(
      x = date,
      ymin = min_value,
      ymax = max_value, colour = compartment
    ),
    alpha = 0.3, colour = NA
    ) +
    geom_hline(
      data = peaks.dt %>% group_by(compartment) %>% summarise(mean_peak = mean(peak)),
      aes(yintercept = mean_peak, colour=compartment), linetype = "dashed"
    ) +
    geom_line(data = cumulative_median_values, aes(x = date, y = median_value, colour = compartment)) +
    facet_grid(compartment ~ ., scales = "free_y", labeller = as_labeller(compartment_names)) +
    scale_colour_manual("", values=brewer.pal(n=4, name="Set2"),
                          breaks=compartments, labels = compartment_names) +
    scale_fill_manual("", values=brewer.pal(n=4, name="Set2"),
                          breaks=compartments, labels = compartment_names) +
    scale_y_continuous(x.main.title, labels = scales::label_number_auto()) +
    coord_cartesian(xlim = timing_limits, expand = FALSE, clip = "off") +
    timing_scale_null +
    thm_main

  legend <- get_legend(p)
  ptiming <- peaks.dt %>% 
    ggplot() +
    labs(subtitle=timing.title)+
    geom_violin(aes(x=peakdate, y=factor(compartment, levels=rev(compartments)),
                    colour=compartment, fill=compartment, group=compartment), 
                alpha=0.4, position = position_identity())+ 
    scale_colour_manual("", values=brewer.pal(n=4, name="Set2"),
                          breaks=compartments, labels = compartment_names) +
    scale_fill_manual("", values=brewer.pal(n=4, name="Set2"),
                          breaks=compartments, labels = compartment_names) +
    timing_scale +
    coord_cartesian(xlim = timing_limits, expand = FALSE, clip = "off")+
    theme_minimal()+
    thm_bottom
  p2 <- plot_grid(
    p + no_legend(),
    ptiming + no_legend(),
    nrow = 2, ncol = 1,
    # labels = c(title, timing.title),
    hjust = 0,
    label_size = 8,
    rel_heights = c(3, 1),
    align = "hv",
    axis = "l"
  )
  if(use.legend){
  return(
    plot_grid(p2, legend, nrow = 1, ncol = 2, rel_widths = c(4, 1))
  )
  }else{
    return(p2)
  }
}

tsplotter <- function(subdt, 
                      title = NULL, 
                      timing.title = "Peak Timing", 
                      pop = poppyra, legend.position="bottom") {
  refdt <- calculate_reference_table(subdt %>% filter(compartment %in% compartments),
                                     by = c("run", "date", "population", "compartment", "age"))

  peaks.dt <- calculate_peaks(refdt, by = c("run", "age", "population", "compartment"))
  timing.dt <- calculate_timings(peaks.dt, by = c("age", "population", "compartment"))
  size.dt <- calculate_peak_sizes(peaks.dt, by = c("age", "population", "compartment"))
  if (!is.na(params$day0)) {
    start_date <- as.Date(params$day0)
    timing.dt <- timing.dt %>%
      mutate_if(is.numeric, function(x) {
        start_date + x
      })
    refdt <- refdt %>%
      mutate(date = start_date + date)
     peaks.dt <- peaks.dt %>%
      mutate(peakdate = start_date + peakdate)
    timing_limits <- c(start_date, start_date + ulim)
    timing_scale <- scale_x_date("Date", date_breaks = "1 month", date_labels = "%b", expand = c(0, 0))
    timing_scale_null <- scale_x_date("", date_breaks = "1 month", labels = NULL, expand = c(0, 0))
  } else {
    timing_limits <- c(refday, refday + ulim)
    timing_scale <- dtscale
    timing_scale_null <- dtscale
  }

  cumulative_median_values <- calculate_cumulative_median_values(refdt, by=c("compartment", "age"))
  plot_list <- list()
  i <- 1
  for(c in names(compartment_names))
  {
    if(!(c %in% refdt$compartment)){
      next()
    }
    y_axis_name <- compartment_names[[c]]
    if(is.null(title)){
      title_1 <- y_axis_name
    }else{
      title_1 <- title[i]
    }
      # Generate the plots
    p <- refdt %>% 
      filter(compartment == c) %>% 
      mutate(compartment = factor(compartment, levels = compartments)) %>%
      group_by(compartment, date, age) %>%
      summarise(
        mean_value = mean(value),
        std_value = sd(value),
        min_value = min(value),
        max_value = max(value)
      ) %>%
      ggplot(aes(group = age, fill = age)) +
      labs(title=title_1)+
      geom_ribbon(aes(
        x = date,
        ymin = min_value,
        ymax = max_value, 
        colour = age
      ),
      alpha = 0.3, colour = NA
      ) +
      geom_hline(
        data = peaks.dt %>% 
          filter(compartment==c) %>% 
          group_by(compartment, age) %>% summarise(mean_peak = mean(peak)),
        aes(yintercept = mean_peak, colour=age), linetype = "dashed"
      ) +
      geom_line(data = cumulative_median_values %>% 
                  filter(compartment == c),
                aes(x = date, y = median_value, colour = age)) +
      # facet_grid(compartment ~ ., scales = "free_y", labeller = as_labeller(compartment_names)) +
      scale_colour_brewer("Age", palette="Dark2") +
      scale_fill_brewer("Age", palette="Dark2") +
      # scale_fill_manual("", values=brewer.pal(n=4, name="Dark2"),
                            # breaks=compartments, labels = compartment_names) +
      scale_y_continuous(y_axis_name, labels = scales::label_number_auto()) +
      coord_cartesian(xlim = timing_limits, expand = FALSE, clip = "off") +
      timing_scale_null +
      thm_main
    legend <- get_legend(p + theme(legend.position = legend.position))
    
    ptiming <- peaks.dt %>% 
      filter(compartment == c) %>% 
      ggplot() +
      labs(subtitle=timing.title)+
      geom_violin(aes(x=peakdate, y=age,
                      colour=age, fill=age, group=age), 
                  alpha=0.4, position = position_identity())+ 
      scale_colour_brewer("Age", palette="Dark2") +
      scale_fill_brewer("Age", palette="Dark2") +
      timing_scale +
      coord_cartesian(xlim = timing_limits, expand = FALSE, clip = "off")+
      theme_minimal()+
      thm_bottom
    
    p_temp <- plot_grid(
        p + no_legend(), 
        ptiming  + no_legend(), 
        NULL,
        nrow = 2, ncol = 1,
        # rel_widths = c(3, 1), 
        rel_heights = c(3, 2),
        align = "hv"
      )
    plot_list[[i]] <- p_temp
    i <- i+ 1
  }
  if(length(plot_list) == 4){
    p_combined <- plot_grid(plot_list[[1]],
            plot_list[[2]],
            plot_list[[3]],
            plot_list[[4]],
            nrow=2, ncol=2, align="hv")
  }else{
    p_combined <- plot_list[[1]]
  }
  if(legend.position == "bottom"){
    p_out <- plot_grid(p_combined, 
                     legend, 
                     nrow = 2, ncol = 1, 
                     rel_heights = c(5, 1))
  }else{
    p_out <- plot_grid(p_combined, 
                     legend, 
                     nrow = 1, ncol = 2, 
                     rel_widths = c(4, 1))
  
  }
  
  return(p_out)
}

tsCplotter <- function(subdt, title, timing.title, legend.position) {
  tsplotter(subdt[between(date, refday, refday + ulim)][,
    .(value = sum(value)),
    keyby = .(run, date, population, compartment, age)
  ][,
    .(value = cumsum(value), date),
    keyby = .(run, population, compartment, age)
  ], title=title, timing.title=timing.title, legend.position=legend.position)
}

summary_tsCplotter <- function(subdt, title, timing.title, y.axis.title, use.legend) {
  summary_tsplotter(subdt[between(date, refday, refday + ulim)][,
    .(value = sum(value)),
    keyby = .(run, date, population, compartment, age)
  ][,
    .(value = cumsum(value), date),
    keyby = .(run, population, compartment, age)
  ], title, timing.title, y.axis.title, use.legend = use.legend)
}
```

# Overview

The World Health Organization (WHO) declared COVID-19 a public health emergency of international concern [@RN7] and then a pandemic [@RN8], citing its rapid global spread and risk of overwhelming healthcare services with patients requiring critical care. This is of particular concern in low- and middle-income countries where resources were already limited and over-stretched.

Cases of COVID-19 in African countries have tended to have been reported later than elsewhere around the world. If this means that the epidemics in Africa are less advanced to date than those elsewhere then perhaps the experience of other countries can help African countries to act fast in preparing for the impact of COVID-19. That said, the total number of reported cases across Africa has already exceeded 10 000 as of 7 April 2020.

In this country-level report, we use a stochastic age-structured dynamic transmission model to predict the scale of the epidemic and time to key events such as the predicted peaks in (i) onset of symptoms, (ii) prevalence of cases needed general or critical hospitalisation, (iii) daily deaths and (iv) cumulative deaths. We also supply the age-distribution breakdown of these predictions.

# Methods, data and assumptions

We used the stochastic age-structured dynamic transmission model reported in [@davies2020].

## Dynamic transmission model 

We analysed a stochastic compartmental model stratified into 5-year age bands, with individuals classified according to current disease status (Fig. 1) and transmission between groups based on UK social mixing patterns ([@davies_age_2020;@mossong2008social]; full details in Supplementary Information). After infection with SARS-CoV-2 in the model, susceptible individuals pass through a latent period before becoming infectious, either with a preclinical and then clinical infection, or with a subclinical infection, before recovery or isolation. We refer to those infections causing few or no symptoms as subclinical. We assume older individuals are more likely to show clinical symptoms [@davies_age_2020].

## Key model parameters 

We collated multiple sources of evidence to estimate key model parameters (Table S1). In a meta-analysis, we estimated that the basic reproduction number, $R_0$, was 2.7 (95% credible interval: 1.6–3.9) across settings without substantial control measures in place ($R_0$ describes the average number of secondary infections caused by a typical primary infection in a completely susceptible population). We derived age-stratified case fatality ratios (CFR) to estimate a CFR that ranged substantially across age groups, from 0.1% in the 20–29 age group to 7.7% in the over-80 age group.

## Key parameters of the transmission model 

We used a serial interval of 6.5 days based on published studies [@li2020early;@bi2020epidemiology;@nishiura2020serial], and assumed that the length of the preclinical period was 30% of the total period of clinical infectiousness [@liu2020contribution]. From this, we fixed the mean of the latent period to 4 days, the mean duration of preclinical infectiousness to 1.5 days, and the mean duration of clinical infectiousness to 3.5 days. The basic reproduction number $R_0$ was estimated by synthesizing the results of a literature review (Fig. S1). For each reported value of the basic reproduction number, we matched a flexible PERT distribution (a shifted beta distribution parameterised by minimum, maximum, and mode) to the median and confidence interval reported in each study. We sampled from the resulting distributions, weighting each study equally, to obtain estimates of $R_0$ for our simulations. The age-specific clinical fraction, $y_i$, was adopted from an estimate based on case data from 6 countries [@davies_age_2020], and the relative infectiousness of subclinical cases, $f$, was assumed to be 50% relative to clinical cases, as we assumed in a previous study [@davies_age_2020].

## Hospital burden estimation

To calculate ICU and non-ICU beds in use through time, we scaled age-stratified symptomatic cases by age-specific hospitalisation and critical outcome probability, then summed to get the total number of hospitalised and critical cases. We then distributed hospitalised cases over time based on expected time of hospitalisation and duration admitted. We assumed gamma-distributed delays, with the shape parameter set equal to the mean, for: delay from symptom onset to hospitalisation of mean 7 days (standard deviation 2.65) [@linton2020incubation;@cao2020trial]; delay from hospitalisation to discharge / death for non-ICU patients of mean 8 days (s.d. 2.83) [@NHSDigital]; delay from hospitalisation to discharge / death for ICU patients of mean 10 days (s.d. 3.16) [@cao2020trial]; and delay from onset to death of mean 22 days (s.d. 4.69) [@linton2020incubation;@cao2020trial]. We calculated the age-specific case fatality ratio based on data from the COVID-19 outbreak in China and on the Diamond Princess cruise ship. We first calculated the naive case fatality ratio, nCFR, (i.e. deaths/cases) for each age group, then scaled down the naive CFR based on a correction factor estimated from data from the Diamond Princess [@russell2020] to give an adjusted CFR. We then calculated risk of hospitalisation based on the ratio of severe and critical cases to cases (18.5%) and deaths to cases (2.3%) in the early China data, which we took to imply 8.04 times more hospitalisations than deaths in each age group. We assumed all age groups had a 30% risk of requiring critical care if hospitalised [@cao2020trial].”

## Population Structure

TODO: indicate if synthetic or not; indicate if analogy or not

```{r echo=FALSE, fig.height=2.5}
plotter <- function(pop) {
  p <- ggplot(pop) +
    aes(x = age, y = pop / 1000) +
    geom_col(fill = "#cc3366") +
    coord_flip() +
    labs(x = NULL, y = "Population (thousands)") +
    theme_minimal()
  return(p)
}
sp_contact_matrices <- function(mat, legpos = "right") {
  mat <- Reduce(function(l, r) l + r, mat)
  data <- data.table(reshape2::melt(mat))
  names(data) <- c("From", "To", "Contacts")
  ggplot(data) +
    geom_raster(aes(x = To, y = From, fill = Contacts)) +
    scale_fill_viridis_c() +
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
      strip.background = element_rect(fill = "white", colour = "white"),
      legend.position = legpos,
    )
}
plot_grid(plotter(poppyra), sp_contact_matrices(contactmatrices), ncol = 2)
```

```{r echo=FALSE, warning=FALSE}

calculate_max_peak <- function(subdt) {
  if (!is.na(params$day0)) {
    refdt <- calculate_reference_table(subdt)
    peaks.dt <- calculate_peaks(refdt)
    timing.dt <- calculate_timings(peaks.dt)
    start_date <- as.Date(params$day0)
    return(paste0(format(start_date + timing.dt$md[1], "%d/%m/%Y"), " to ", format(start_date + timing.dt$hi[1], "%d/%m/%Y")))
  } else {
    return("")
  }
}
calculate_max_peak_and_days <- function(subdt) {
  refdt <- calculate_reference_table(subdt)

  peaks.dt <- calculate_peaks(refdt)
  timing.dt <- calculate_timings(peaks.dt)
  if (!is.na(params$day0)) {
    start_date <- as.Date(params$day0)
    return(paste0(
      format(start_date + timing.dt$md[1], "%d/%m/%Y"), " to ", format(start_date + timing.dt$hi[1], "%d/%m/%Y"),
      ", which is ", timing.dt$md[1], " to ", timing.dt$hi[1], " days after the first reported case"
    ))
  } else {
    return(paste0(timing.dt$md[1], " to ", timing.dt$hi[1], " days after the first reported case"))
  }
}

calculate_peak_number_median <- function(subdt) {
  refdt <- calculate_reference_table(subdt)

  peaks.dt <- calculate_peaks(refdt)
  q <- quantile(peaks.dt$peak, probs = c(0.25, 0.75, 0.025, 0.975))
  return(paste0(
    scales::number(q[1]), " - ",
    scales::number(q[2]), " (",
    scales::number(q[3]), " - ",
    scales::number(q[4]), ", 95% CI)"
  ))
}

#' Calculates the date that the number of *value* hits 99% of the maximum.
calculate_cumulative_total <- function(subdt) {
  ds <- subdt %>%
    group_by(run, date) %>%
    summarise(total_value = sum(value)) %>%
    arrange(run, date) %>%
    group_by(run) %>%
    mutate(cum_value = cumsum(total_value)) %>%
    group_by(run) %>%
    mutate(max_value = 0.99 * max(cum_value)) %>%
    filter(max_value <= cum_value) %>%
    top_n(n = 1, wt = desc(date)) %>%
    ungroup()

  q_dates <- format(quantile(ds %>%
    select(date) %>%
    pull(),
  probs = c(0.25, 0.75, 0.025, 0.975)
  ) + as.Date(params$day0), "%d/%m/%Y")
  q_max_value <- round(quantile(ds %>%
    select(max_value) %>%
    pull(), probs = c(0.25, 0.75, 0.025, 0.975)))
  q_days <- quantile(ds %>%
    select(date) %>%
    pull(), probs = c(0.25, 0.75, 0.025, 0.975))
  return(paste0(
    q_max_value[1], " - ", q_max_value[2], " (", q_max_value[3], " - ", q_max_value[4], ", 95% CI)", " occuring on ", q_dates[1], " - ", q_dates[2], " (", q_dates[3], " - ", q_dates[4], ", 95% CI)",
    ", approximately ", q_days[1], " - ", q_days[2],
    " days after the first reported case (", q_days[3], " - ", q_days[4], " days, 95% CI)"
  ))
}

calculate_dates_difference <- function(subdt1, subdt2) {
  refdt1 <- calculate_reference_table(subdt1)
  refdt2 <- calculate_reference_table(subdt2)
  compartment1 <- refdt1$compartment[1]
  peaks.dt <- calculate_peaks(refdt1) %>%
    pivot_wider(id_cols = c(run, population, peakdate), names_from = compartment, values_from = peak) %>%
    rename(peakdate1 = peakdate) %>%
    full_join(calculate_peaks(refdt2) %>%
      pivot_wider(
        id_cols = c(run, population, peakdate),
        names_from = compartment, values_from = peak
      ) %>%
      rename(peakdate2 = peakdate), by = c("run", "population")) %>%
    mutate(peakdate = peakdate2 - peakdate1)

  days_difference <- calculate_timings(peaks.dt, by = c("population"))
  if (days_difference$md - days_difference$lo.lo > 2) {
    return(paste0(days_difference$lo, " - ", days_difference$hi, " days later (", days_difference$lo.lo, " - ", days_difference$hi.hi, " days, 95% CI"))
  } else {
    return(paste0(days_difference$lo.lo, " - ", days_difference$hi.hi, " days later (95% CI)"))
  }
}

peaks_dates_and_days_after <- list(
  cases_reported = calculate_max_peak_and_days(subdyn[compartment == "cases_reported"]),
  nonicu_p = calculate_max_peak_and_days(subdyn[compartment == "nonicu_p"]),
  icu_p = calculate_max_peak_and_days(subdyn[compartment == "icu_p"]),
  death_o = calculate_max_peak_and_days(subdyn[compartment == "death_o"])
)

peaks_dates <- list(
  cases_reported = calculate_max_peak(subdyn[compartment == "cases_reported"]),
  nonicu_p = calculate_max_peak(subdyn[compartment == "nonicu_p"]),
  icu_p = calculate_max_peak(subdyn[compartment == "icu_p"]),
  death_o = calculate_max_peak(subdyn[compartment == "death_o"])
)

peaks_median_numbers <- list(
  cases_reported = calculate_peak_number_median(subdyn[compartment == "cases_reported"]),
  nonicu_p = calculate_peak_number_median(subdyn[compartment == "nonicu_p"]),
  icu_p = calculate_peak_number_median(subdyn[compartment == "icu_p"]),
  death_o = calculate_peak_number_median(subdyn[compartment == "death_o"])
)
dates_difference <- list(
  cases_vs_icu = calculate_dates_difference(
    subdyn[compartment == "cases_reported"],
    subdyn[compartment == "nonicu_p"]
  ),
  icu_vs_death = calculate_dates_difference(
    subdyn[compartment == "nonicu_p"],
    subdyn[compartment == "death_o"]
  )
)
cumulative_totals <- list(
  cases_reported = calculate_cumulative_total(subdyn[compartment == "cases_reported"]),
  nonicu_p = calculate_cumulative_total(subdyn[compartment == "nonicu_p"]),
  icu_p = calculate_cumulative_total(subdyn[compartment == "icu_p"]),
  death_o = calculate_cumulative_total(subdyn[compartment == "death_o"])
)
```

# Overall Results

The following series of plots show overall outcomes, particularly: incidence of cases, prevalence of hospitalised patients, and incidence and cumulative incidence of deaths.

Figure 1 shows that the median peak number of symptomatic cases across all model projections is `r peaks_median_numbers$cases_reported`, forecast to occur on `r peaks_dates_and_days_after$cases_reported`. The predicted peak in hospitalised cases occurs about `r dates_difference$cases_vs_icu` (Figures 2 and 3), with a median of `r peaks_median_numbers$nonicu_p` cases in ward and `r peaks_median_numbers$icu_p` in ICU on `r peaks_dates$nonicu_p`. The peak daily number of deaths is predicted to follow about `r dates_difference$icu_vs_death` on `r peaks_dates$death_o`, with the median estimate of `r peaks_median_numbers$death_o` new deaths that day (Figure 4). Figure 5 shows that the cumulative number of deaths is predicted to be `r cumulative_totals$death_o`. 

```{r echo=FALSE, fig.height=9}
summary_tsplotter(subdyn)
```

```{r echo=FALSE, fig.height=3}
summary_tsCplotter(subdyn[compartment == "death_o"], "A) Cumulative Deaths", 
                   timing.title = "B) Last Timing", y.axis.title = "Deaths", 
                   use.legend=FALSE)
```
```{r echo=FALSE}

calculate_age_distribution <- function(subdt) {
  refdt <- calculate_reference_table(subdt, by = c("run", "date", "population", "compartment", "age")) %>%
    group_by(run, age) %>%
    summarise(total_value = sum(value)) %>%
    group_by(run) %>%
    mutate(total_percent = 100 * total_value / sum(total_value)) %>%
    group_by(age) %>%
    summarise(
      lo.lo = quantile(total_percent, c(0.025)),
      lo = quantile(total_percent, c(0.25)),
      md = quantile(total_percent, c(0.5)),
      hi = quantile(total_percent, c(0.75)),
      hi.hi = quantile(total_percent, c(0.975)),
      lo_value = quantile(total_value, c(0.25)),
      md_value = median(total_value),
      hi_value = quantile(total_value, c(0.75)),
      description = ifelse(round(lo.lo) == round(hi.hi),
        paste0(round(md), "% (within 95% CI)"),
        paste0(round(lo.lo), " - ", round(hi.hi), "% (95% CI)")
      ),
      range_value = ifelse(round(lo_value) == round(hi_value), paste0(scales::number(round(hi_value))),
        paste0(scales::number(round(lo_value)), " - ", scales::number(round(hi_value)))
      )
    )
  return(refdt)
}

calculate_peak_number_median_age <- function(subdt) {
  refdt <- calculate_reference_table(subdt, by = c("run", "date", "population", "compartment", "age"))

  peaks.dt <- calculate_peaks(refdt, by = c("run", "population", "compartment", "age")) %>%
    group_by(age) %>%
    summarise(
      lo.lo = quantile(peak, c(0.025)),
      lo = quantile(peak, c(0.25)),
      md = quantile(peak, c(0.5)),
      hi = quantile(peak, c(0.75)),
      hi.hi = quantile(peak, c(0.975))
    )
  # q <- quantile(peaks.dt$peak, probs = c(0.25, 0.75, 0.025, 0.975))
  return(peaks.dt)
}

calculate_cumulative_median_age <- function(subdt) {
  refdt <- calculate_reference_table(subdt, by = c("run", "date", "population", "compartment", "age"))

  peaks.dt <- refdt %>%
    group_by(run, age) %>%
    summarise(total_value = sum(value)) %>%
    ungroup() %>%
    group_by(age) %>%
    summarise(
      lo.lo = quantile(total_value, c(0.025)),
      lo = quantile(total_value, c(0.25)),
      md = quantile(total_value, c(0.5)),
      hi = quantile(total_value, c(0.75)),
      hi.hi = quantile(total_value, c(0.975))
    )
  # q <- quantile(peaks.dt$peak, probs = c(0.25, 0.75, 0.025, 0.975))
  return(peaks.dt)
}

age_distribution_percentages <- list(
  cases_reported = calculate_age_distribution(subdyn[compartment == "cases_reported"]),
  nonicu_p = calculate_age_distribution(subdyn[compartment == "nonicu_p"]),
  icu_p = calculate_age_distribution(subdyn[compartment == "icu_p"]),
  death_o = calculate_age_distribution(subdyn[compartment == "death_o"])
)

peaks_median_by_age <- list(
  cases_reported = calculate_peak_number_median_age(subdyn[compartment == "cases_reported"]),
  nonicu_p = calculate_peak_number_median_age(subdyn[compartment == "nonicu_p"]),
  icu_p = calculate_peak_number_median_age(subdyn[compartment == "icu_p"]),
  death_o = calculate_peak_number_median_age(subdyn[compartment == "death_o"])
)
cumulative_median_by_age <- list(
  cases_reported = calculate_cumulative_median_age(subdyn[compartment == "cases_reported"]),
  nonicu_p = calculate_cumulative_median_age(subdyn[compartment == "nonicu_p"]),
  icu_p = calculate_cumulative_median_age(subdyn[compartment == "icu_p"]),
  death_o = calculate_cumulative_median_age(subdyn[compartment == "death_o"])
)
under_15_symtomatic_percentage <- age_distribution_percentages$cases_reported %>%
  filter(age == "<14") %>%
  select(description) %>%
  pull()
over_60_symtomatic_percentage <- age_distribution_percentages$cases_reported %>%
  filter(age == "60+") %>%
  select(description) %>%
  pull()
median_ward_over_60 <- age_distribution_percentages$nonicu_p %>%
  filter(age == "60+") %>%
  select(md_value) %>%
  pull() %>%
  scales::number()
median_ward_45_59 <- age_distribution_percentages$nonicu_p %>%
  filter(age == "45-59") %>%
  select(md_value) %>%
  pull() %>%
  scales::number()
median_icu_over_60 <- age_distribution_percentages$icu_p %>%
  filter(age == "60+") %>%
  select(md_value) %>%
  pull() %>%
  scales::number()
median_icu_45_59 <- age_distribution_percentages$icu_p %>%
  filter(age == "45-59") %>%
  select(md_value) %>%
  pull() %>%
  scales::number()
peaks_median_over_60 <- peaks_median_by_age$death_o %>%
  filter(age == "60+") %>%
  select(md) %>%
  round() %>%
  pull() %>%
  scales::number()
peaks_median_45_59 <- peaks_median_by_age$death_o %>%
  filter(age == "45-59") %>%
  select(md) %>%
  round() %>%
  pull() %>%
  scales::number()
cumulative_median_death_over_60 <- cumulative_median_by_age$death_o %>%
  filter(age == "60+") %>%
  select(md) %>%
  round() %>%
  pull() %>%
  scales::number()
cumulative_median_45_59 <- cumulative_median_by_age$death_o %>%
  filter(age == "45-59") %>%
  select(md) %>%
  round() %>%
  pull() %>%
  scales::number()
```

\clearpage

## Results by Age Group

Each plot includes several stochastic timelines, and shows marginal distributions for the height and timing of peaks.

Figure 6 simply shows that the percentage of symptomatic cases in each age group is mostly in proportion to the age structure of the country, with `r under_15_symtomatic_percentage` being under the age of 15 and `r over_60_symtomatic_percentage` being aged 60 or over. However, the age distribution of hospitalised cases is inverted (Figures 7 and 8), with the predicted median number of hospitalisations of those aged 60 and over much higher than among those aged 45-59 (`r median_ward_45_59` versus `r median_ward_over_60` in ward and `r median_icu_over_60` versus `r median_icu_45_59` in ICU). This pattern in the upper age groups is maintained for the predicted median peak in the daily number of deaths (`r peaks_median_over_60` among those aged 60 and over versus `r peaks_median_45_59` among those aged 45-59) and cumulative number of deaths (`r cumulative_median_death_over_60` among those aged 60 and over versus `r cumulative_median_45_59` among those aged 45-59). Generally, the number of hospitalisations and deaths increase with each increasing age band, although there seems little, if any, difference between those aged 15-29 and those aged 30-44 in this respect. Across Figures 6-10, we see that peak times for symptomatic cases, hospitalisations and deaths occur slightly earlier among younger age groups compared with older age groups, with this difference being most notable for cumulative deaths.

```{r echo=FALSE, fig.height=9}
tsplotter(subdyn)
```


```{r echo=FALSE, fig.height=4}
tsCplotter(subdyn[compartment == "death_o"], title="Cumulative Deaths", timing.title = "Last Timing", legend.position="right")
```

```{r, echo=FALSE}
suppressWarnings(output <- subdyn %>% 
                   filter(compartment %in% compartments) %>% 
                   group_by(compartment, age, run) %>% 
                   summarise(total = sum(value)) %>% 
                   group_by(compartment, age) %>% 
                   summarise(mean_value = round(mean(total))) %>% 
                   full_join(data.frame(compartment_names) %>% rownames_to_column("compartment"), by="compartment") %>% 
                   ungroup() %>% 
                   select(-compartment) %>% 
                   pivot_wider(id_cols=age, names_from=compartment_names, values_from=mean_value) %>% 
                   rename(Age=age) %>% 
                   select(Age, `Symptomatic Cases`, `Hospitilised Cases (Ward)`, `Hospitilised Cases (ICU)`, Deaths)) 
                   
kable(output)
```


\clearpage

# Conclusions

Based on the projections, there is likely to be a large number of cases and high demand for medical care. Preparedness activities are needed.

# References
